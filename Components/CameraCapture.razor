@using Microsoft.JSInterop
@inject IJSRuntime JS
@inject PhotoStoreService PhotoStore
@implements IAsyncDisposable

<MudPaper Class="camera-capture" Elevation="1">
    <MudStack Spacing="1">
        <MudPaper Class="camera-context" Elevation="0">
            <MudText Typo="Typo.h6">@Planogram?.Name</MudText>
            <MudText Typo="Typo.body2">Segment @(CurrentIndex + 1) of @(Planogram?.NumberOfSegments ?? 0)</MudText>
        </MudPaper>

        @if (CameraError is not null)
        {
            <MudAlert Severity="Severity.Error" Elevation="0">@CameraError</MudAlert>
        }
        else if (Planogram is not null && Planogram.NumberOfSegments > 0)
        {
            <MudPaper Class="camera-view" Elevation="0">
                <video id="@VideoElementId" autoplay playsinline muted></video>
                @if (!_cameraStarted)
                {
                    <div class="camera-loading">
                        <MudProgressCircular Indeterminate="true" Color="Color.Primary" Size="Size.Medium" />
                        <MudText Typo="Typo.body2">Starting camera…</MudText>
                    </div>
                }
                <div class="camera-actions">
                    <MudButton Color="Color.Primary"
                               Variant="Variant.Filled"
                               Disabled="@(IsCapturing || !_cameraStarted)"
                               ButtonType="ButtonType.Button"
                               OnClick="CapturePhoto">
                        @(IsCapturing ? "Capturing…" : "Take photo")
                    </MudButton>
                </div>
            </MudPaper>
        }
    </MudStack>
</MudPaper>

@code {
    [Parameter] public Planogram? Planogram { get; set; }
    [Parameter] public int CurrentIndex { get; set; }
    [Parameter] public EventCallback<int> OnSegmentCaptured { get; set; }

    private const string VideoElementId = "planogram-camera-video";
    private DotNetObjectReference<CameraCapture>? _dotNetRef;
    private bool _cameraStarted;
    private string? _cameraError;
    private bool _isCapturing;

    private string? CameraError => _cameraError;
    private bool IsCapturing => _isCapturing;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Planogram is not null && Planogram.NumberOfSegments > 0)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await StartCameraAsync();
        }
    }

    private async Task StartCameraAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("PlanogramCamera.startCamera", VideoElementId);
            _cameraStarted = true;
            _cameraError = null;
        }
        catch (Exception ex)
        {
            _cameraError = $"Camera error: {ex.Message}";
        }
        StateHasChanged();
    }

    private async Task CapturePhoto()
    {
        if (Planogram is null || _isCapturing) return;
        _isCapturing = true;
        StateHasChanged();
        try
        {
            await JS.InvokeVoidAsync("PlanogramCamera.capturePhoto", VideoElementId, _dotNetRef);
        }
        finally
        {
            _isCapturing = false;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnPhotoCaptured(string base64ImageData)
    {
        if (Planogram is null) return;
        var segmentNumber = CurrentIndex + 1;
        PhotoStore.StorePhoto(Planogram.Id, segmentNumber, base64ImageData);
        InvokeAsync(async () =>
        {
            await OnSegmentCaptured.InvokeAsync(CurrentIndex);
            StateHasChanged();
        });
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("PlanogramCamera.stopCamera");
        }
        catch { /* ignore when JS not available */ }
        _dotNetRef?.Dispose();
    }
}
